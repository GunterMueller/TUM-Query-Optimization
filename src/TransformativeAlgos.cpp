#include "TransformativeAlgos.hpp"

using namespace std;

//Transformation rules
//Modify directly
//Commutativity: swap left and right sub tree of the join
void commutativity(unique_ptr<JoinTree> join) {
    //The swap
    join->leftSub.swap(join->rightSub);
    //To reduce the number of duplicates, disable T1-T3 for new tree
    //TODO: Disable transformations
    
}




/** Implementation of the tranformative algorithm
 * that makes use of the memo structure
 **/
JoinTree TransformativeAlgos::exhaustiveTrans2(QueryGraph graph) {
    //1. Initialize MEMO

    //2. ExploreClass 

    //3. return minimal join tree from the class
}

/**
 * The exploration method
 * Considers *all* alternatives on one class and applies transformation
**/
void TransformativeAlgos::exploreClass(unique_ptr<JoinTree> treeClass) {

    //while not all trees of C have been explored
    while(0) {
        //1. choose some unexplored tree

        //2. ApplyTransformation2

        //3. Mark T as explored
    }

}
/**
 * Actual application of the transformations
 * Here: RuleSet RS-1 from the lecture
 **/
void TransformativeAlgos::applyTrans(JoinTree theTree) {

    //1. Before doing anything, descend into child trees
    exploreClass(std::move(theTree.leftSub));
    exploreClass(std::move(theTree.rightSub));

    //2. for every rule and for every member of child "classes"

    //Rules are implemented as private functions

        //3. Add every tree generated by applying a transformation to MEMO
        // In the class we are currently in

}